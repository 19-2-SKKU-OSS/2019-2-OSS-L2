BIT ALGORITHM
==========================
Algorithms that use bit-level operations, such as little endian and big endian. 
Use arithmetic symbols such as and, or, xor, shift, etc. to determine whether they are multiples, etc.

Followings are implemented: 
- detect_opposite_signs.c
- find_single_number.c
- swap_bits.c
- add_two_number.c
- smallest_of_three.c
- boolean_array_puzzle.c
- next_higher_number.c
- count_total_set_bits.c
- add_1.c
- multiply_with_7.c
- turn_of_rightmost_Set_bit.c
- check_power_of_4.c
- compute_absolute_value_without_branching.c
- modulus_division_by_a_power_of_2_number.c
- compute_minimum_or_maximum_without_branch.c
- rotate_bits.c
- find_two_nonrepeating_element.c
- odd_number_of_time.c
- binary_representation_of_a_given_Number.c
- check_if_a_number_is_multiple_of_3.c
- check_if_a_number_is_multiple_of_9.c
- check_if_binary_representation_of_a_number_is_palindrome.c
- count_number_of_bits_to_be_flipped_to_conver_a_to_b.c
- count_set_bits_in_an_integer.c
- find_party.c
- find_position_of_the_only_set_bit.c
- find_whether_a_np_is_power_of_two.c
- how_to_swap_two_numbers_without_using_a_temporary_variable.c
- how_to_turn_off_a_particular_bit_in_a_number.c
- Karatsuba_algorithm.c
- little_and_big_endian_mystery.c
- multiply_with_7.c
- next_power_of_2.c
- position_of_rightmost_set_bit.c
- reverese_bits_of_a_number.c
- swap_all_odd_and_even_bits.c
- swap_two_nibbles_in_a_byte.c
